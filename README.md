# Lesson 10. 配列(Array)とオブジェクト(Object)

## 目的

- 配列の概念と基本的な操作方法を知る。
- オブジェクトの概念と基本的な操作方法を知る。

## 配列(Array)とは

**_配列（Array）_**とは、オブジェクトのように複数のデータを一度に処理するために存在する構造です。レッスン2で簡単に概要を学びましたが、このレッスンではより詳しく**_配列_**について学んでいきます。

**_配列_**に記憶されるデータには順番が決まっていて、「[]」(ブラケット)を使用して0から始まる一連の整数として扱うことや、異なる型も配列要素に含めることができ、オブジェクトや配列要素自体を配列要素として含めることができること、`length`を使用して配列内の要素数を返すこと、特定の配列要素の書き換えが可能ということを、レッスン2では確認してきました。

また、**_配列_**は0から始めるインデックスを使用することで、特定要素にもアクセスできるという特性が大変便利で、様々なデータ処理が簡単に記述できます。

## 配列の宣言

**_配列_**の宣言方法には2つあります。**配列コンストラクタArray()を使う方法**と、**配列リテラルの[]（ブラケット）を使う方法**です。

**_配列コンストラクタ_**を使うときに少しだけ気をつけたいのは、`new`を使用して`Array()`の引数に格納する配列要素を書きます。

**_配列コンストラクタ_**と**_配列リテラル_**の実例を見て、書き方の区別を視覚的に理解しましょう。

```js
let array = new Array(1, 2, 3, 4);
console.log(array); // [1, 2, 3, 4]

let literal = [1, 2, 3, 4];
console.log(literal); // [1, 2, 3, 4]
```

これだけ見ると、**_配列コンストラクタ_**も配列リテラルも大差ないので、どちらで書いても同じと思われがちですが、実は1つだけの数値要素を格納すると出力結果に差が出ます。

```js
let array = new Array(4);
console.log(array); // [ , , , ] もしくは [empty x 4]

let literal = [4];
console.log(literal); // [4]
```

**_配列コンストラクタ_**は数値1つだけの要素が配列に格納されている場合は、空の配列要素を4つ用意していますが、**_配列リテラル_**は数値の4を戻り値として返しています。
これはJavascriptの仕様によって起こっている現象です。

このことからも、無意識に数値1つだけを配列要素として書くのをしてしまった時のことを想定して、基本的には配列は**「配列リテラル」**で書くのが望ましいため、CodeGritでも基本的には**_配列リテラル_**で書いていきます。

## スプレッド演算子(...)について

省略の意味で書かれているように見えますが、これは**_スプレッド演算子_**というES6標準の演算子です。
記述方法は`...arr`のように書かれ、配列やオブジェクトの要素を**「展開=spread」**する演算子です。
**_スプレッド演算子_**は配列と、このレッスンの後半に出てくるオブジェクトで使用することができます。

まずは**_配列_**での使用例を実際に見てみましょう。

```js
const arr = [1, 2];

// 上記arr配列のクローン
const arrClone = [...arr];
console.log(arrClone); // [1, 2]

// クローンした配列と組み合わせて新しい配列を生成
const addNewArr = [...arr, 3, 4];
console.log(addNewArr); // [1, 2, 3, 4]

// 配列をマージ(統合)する
const arrMerge = [...arr, ...arrClone];
console.log(arrMerge); // [1, 2, 1, 2]
```

**_配列コンストラクタ_**で上記を実現しようとすると、`Array.prototype.concat()` という書き方になりますが、**_配列リテラル_**でスプレッド演算子を書くことで、はるかに簡潔に表記することができます。

オブジェクトのスプレッド演算子表記については以下のオブジェクトの項目を参照してください。

## 配列の初期化

配列を初期化するというのは、**配列を空にする**ということを意味します。
**空の配列を用意する = 配列の初期化**ということなので、以下のようにして、配列の初期化をすることが出来ます。

```js
let array = [];
console.log(array); // []
```

## 配列のメソッド

### 配列の要素の追加

**_pushメソッド_**を使うことで、**配列の最後**に要素を追加することができます。逆に、**_unshiftメソッド_**は**配列の先頭**に要素を追加します。
2つとも戻り値は変更された後の配列の長さを返します。

```js
let arr = ['1', '2', '3'];

console.log(arr.push('4')); // 4(追加された要素を合わせた配列の長さ)
console.log(arr.unshift('0')); // 5(追加された要素を合わせた配列の長さ)
console.log(arr) // ['0', '1', '2', '3', '4']
```

### 配列の要素の削除

**_popメソッド_**を使うことにより、**配列の最後**にある要素を消し、配列そのものを変更することができます。逆に、**_shiftメソッド_**は**配列の先頭**にある要素を削除して、配列そのものを変更します。
**_shiftメソッド_**の戻り値は削除された要素を返します。

```js
let arr = ['1', '2', '3'];

let x = arr.pop();
console.log(x); // '3'
console.log(arr); // ["1", "2"]
console.log(arr.shift()); // '1' (削除された要素)
console.log(arr); // ["2"]
```

**_delete演算子_**を使って配列要素を消すこともできます。削除したい配列要素のインデックス以下のように指定することで、指定された要素だけ消すことができます。
戻り値が文字列の数字だけでは少しつまらないので、カフェのドリンクメニューを想定して、品切れになったラテ マキアートを**_delete演算子_**を使ってメニューから削除してみましょう。

```js
let drinks = [
  'cappccino',
  'latte machiato',
  'ice mocha',
  'chai tea latte',
  'white mocha',
];

delete drinks[1];

console.log(drinks); // ["cappccino", empty, "ice mocha", "chai tea latte", "white mocha"]
```

この例ではインデックスで数えて1番目の配列要素のラテ・マキアートが削除されて配列要素のメニューから削除されたことが確認できました。

今度は複数の配列要素を削除する方法について見ていきましょう。
上記の例ではどれも1つずつ配列要素を削除していて、削除できるのも配列要素の先頭と一番後ろ、指定されたインデックスの箇所1つだけが削除可能でした。

もし、カフェのメニューで複数のドリンクが材料が足りずに品切れになった場合はどうしたらいいのでしょうか？
上記の方法では1つずつ消していくしか方法はありませんが、**_spliceメソッド_**を使うことで複数の、しかも指定した個数と箇所を自由に削除することが可能になります。
カフェのメニューの上から2番目に書いてあるラテ・マキアートとアイス・モカが品切れなので、メニューから削除し、店長にどのメニューが品切れかを伝えましょう。
インデックス0から数えて１番目にある配列要素から2つ配列要素を消すということですね。

```js
let drinks = [
  'cappccino',
  'latte machiato',
  'ice mocha',
  'chai tea latte',
  'white mocha'
];

//1番目から2個の要素を削除した値を「menuResult」に代入
let tellYourBoss = drinks.splice(1, 2);

console.log(tellYourBoss); // 消された配列要素が返される['latte machiato','ice mocha']

console.log(drinks); // 残った配列要素が返される["cappccino", "chai tea latte", "white mocha"]
```

これで無事メニューの上から2番目に書いてあるラテ マキアートとアイス モカを消すことができ、店長にもどのメニューが品切れかを伝えることができました。

### 配列の置き換え

レッスン2でも簡単な置き換えは見てきましたが、先ほどカフェのメニューを品切れドリンクメニューに合わせて臨機応変に複数指定した箇所で消すことができた、**_spliceメソッド_**で置き換えもできる例を見ていきましょう。

品切れとはいえ、メニューが削除されて減ってしまうだけではお客さんの選択肢が狭められてしまいますよね。
品切れのラテマキアートとアイスモカの代わりに、材料が十分にあって用意可能な代用メニューに置き換えてみます。

```js
let drinks = [
  'cappccino',
  'latte machiato',
  'ice mocha',
  'chai tea latte',
  'white mocha'
];

// インデックスで数えて1番目と２番目の要素をラテとアイス ココアに置き換える
drinks.splice(1, 2, 'latte', 'ice coco');
console.log(drinks);// ['cappccino','latte','ice coco','chai tea latte','white mocha']
```

これで品切れのラテマキアートとアイスモカの代用メニューとしてラテとアイス ココアにメニューを書き換えることができました。
メソッドのカッコ中にある例えば「`(1, 2, 'latte', 'ice coco')`」は、左から順にJavaScriptでは **第1引数** **第2引数** **第3引数** **第4引数** と呼びます。（読み仮名は「ひきすう」です。）
書籍などでは引数を使って解説してある内容をよく見かけるので、覚えておくと便利です。

### 配列の値の取り出し

これはレッスン2やこのレッスンの冒頭でも少し述べましたが、配列リテラルでは「[]」（ブラケット）を使ってインデックス番号を0から数えた順番で指定することで、特定の配列要素を呼び出すことができます。以下は例です。

```javascript

const arr = [1, 2, 3, 4]

console.log(arr[0]); // 1
console.log(arr[1]); // 2
console.log(arr[arr.length - 1]); // 4
```

配列の順番は0から始まることに気をつけましょう。上記のように、`arr.length`で配列の長さを得てそこから1を引くことで配列の最後の要素にアクセスすることが出来ます。

### 配列要素の検索

**_indexOf()メソッド_**を使うことで、とても簡単にそれぞれの要素のデータを検索することができます。
ただし、この**_indexOf()メソッド_**は検索したい指定をした要素が存在する場合のみ、存在する順番（場所）をインデックス番号で取得することができるようになっています。

```js
const hello = ['hello', 'こんにちは', 'hallo', 'hola'];
const result = hello.indexOf('こんにちは');

console.log(result); // 1
```

返り値として、インデックスで数えて1番目にある「こんにちは」のインデックス番号が返ってきました。
まず配列の中に「こんにちは」という文字列の要素が存在するかを確認した上での出力結果であることにも注目しましょう。

試しに配列に存在しない要素で検索をしてみます。

```js
const hello = ['hello', 'こんにちは', 'hallo', 'hola'];
const result = hello.indexOf('Bonjour');

console.log(result); // -1
```

-1が返り値として返ってきました。
これは配列内に存在しない要素の検索結果として返ってくる戻り値です。

では、検索したい配列要素が複数重複して存在していた場合は戻り値はどうなるのでしょうか？

実際にコードと反映を見て見ましょう。

```js
const hello = ['hello', 'こんにちは', 'hallo', 'こんにちは'];
const result = hello.indexOf('こんにちは');

console.log(result); // 1
```

1というインデックスが返されましたが、検索した「こんにちは」という配列要素は2箇所あります。
インデックス番号で言うと1と3にあるので、2つ戻り値が返されるのかと思いきや、はじめにある配列要素のインデックス番号しか戻り値として返ってきません。

多い配列を扱う場合は、レッスン7で学んだ**while文**などの繰り返し処理を使い、すべての重複要素を取得する方が良いとされています。

さて、ここまで削除や置き換えを除いて、ほぼインデックス番号でしか戻り値は返ってこないメソッドばかりです。
インデックス番号ではなく、配列要素自体を戻り値としたい場合はどうしたら良いのでしょうか？

そういった場合には**_findメソッド_**を使うことで解決します。

**_findメソッド_**は、`true`を返す配列要素が見つかるまで、つまり検索をかけたい特定の配列要素が見つかるまで、要素に対して一度ずつ関数を実行し、**trueを返した = 検索結果に当てはまる配列要素自体を戻り値**として返します。

```js
const arr = [10, 20, 30, 40];

const arrDiv = arr.filter(value => {
  return ((value % 20) === 0);
});

console.log(arrDiv); // [20, 40] -> 配列の要素が20で割り切れるものだけを配列要素で返す
```

## mapとfilterメソッド

**_map_**は配列データに使うメソッドです。
それぞれの配列要素に**コールバック関数**を実行した結果、新しい配列として返すと言うメソッドです。
具体的には関数の中に実行したい処理内容を書いておくことで、それぞれの配列要素に対して自由に操作することができます。

**_filterメソッド_**は、特定の条件（例：〜以下の数値のみなど）をコールバック関数内に書くことで、その通りに特定条件のデータを取得することができます。
**_map_**と同じで、全ての要素に対して関数をそれぞれ実行しますが、**_filter_**が**_map_**と違う点は、返り値で `true`を返した配列要素にのみ新しい配列データを作ります。

**_map_**はコールバック関数実行対象の配列の数(実行前)と、新たに作成された配列の数(実行後)は変わりません。

**_map_**と**_filter_**の基本構造はそれぞれ以下です。

```js
// mapメソッド
const arr = [配列要素];

arr.map(コールバック関数);

// filterメソッド
const arr = [配列要素];
arr.filter(コールバック関数);
```

説明だけだと**_map_**と**_filter_**の違いを理解するのは少し難しいので、実際に例を見てみましょう。

```js
/*
* map 例
*/
// 配列の「全ての要素」に20を除算した配列を返す

const arr = [10, 20, 30, 40];

const arrDiv = arr.map(value => {
  return value % 20;
});

console.log(arrDiv); // [10, 0, 10, 0] -< 配列要素「全て」に除算すると言う関数内容が実行された計算結果内容で新しい配列が返された
```

```js
/*
* filter 例
*/
// 配列の「除算できる要素のみ」に20を除算した配列を返す

const arr = [10, 20, 30, 40];

const arrDiv = arr.filter(value => {
  return value % 20;
});

console.log(arrDiv);// [10, 30] → 配列要素のうち、「除算できる要素のみ = trueを返す要素のみ戻り値を返す」と言う関数内容が実行され、新しい配列が返された
```

**_map_**が**全ての配列要素**にコールバック関数で指示した条件内容が実行された計算結果を戻り値としているのに対し、**_filter_**ではコールバック関数で指示した**条件内容に当てはまる配列要素のみ**を文字通りフィルターして戻り値を返しています。

当然**_filter_**の実行結果は、コールバック関数の条件内容によって、返ってくる新しい配列の数は、条件に当てはまらないものを弾いた結果であれば関数実行前よりも少ない場合があります。

これは全ての配列要素に対して関数内容を実行する**_map_**との大きな違いです。
上記の具体例で言葉にすると、**_map_**は区別をせず全ての配列要素に割り算をしたのに対し、**_filter_**では**割り切れる配列要素だけを区別 = フィルタリングして結果を返した**という違いになります。


# 配列とfor文の組み合わせ

## 配列とfor文

レッスン7でも一部のサンプルコードなどに配列やオブジェクトと組み合わせたfor文は少しだけ出てきました。
ここではまず**「配列と組み合わせたfor文」**について詳しく見ていきましょう。
**「オブジェクトと組み合わせたfor文」**は以下のオブジェクトの項目に含めていますので、そちらを参照してください。

配列と組み合わせて使えるfor文は以下の種類があります。

```js
// for
let arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// 1 2 3

// for ... of
for (let v of arr) {
  console.log(v);
}
// 1 2 3
```

for文やそのほか、`for ... of`について簡単に復習すると、以下の内容になります。


- **for文** - 条件式（例：`i < arr.length;`など）が`false`になるまでループする。決められた回数だけ処理を繰り返す場合に最適。

- **for ... of** - 配列に含まれる要素を変数として取り出し、その数だけ繰り返し処理をする。繰り返す回数やカウンタ変数を指定しなくても良い。


レッスン7では`for ... in`も習いましたが、配列との組み合わせには例を参照していません。
なぜでしょうか？

これは配列ループに`for ... in`を使用することによるリスクを回避するためです。
JavaScriptの仕様で予想される反映とは違った予期せぬ反映を返すため、配列と`for ... in`は配列ループに使用しない方が良いとされています。

そもそもの`for ... in`の役割自体も、オブジェクトの中身を取得し、その個数分だけ繰り返し処理することを意図しているので、配列ではfor文、もしくは`for ... of`を使用するのが良いとされています。

## 配列とfor-of文

配列との組み合わせだけに限らず、**_for ... of文_**はES6で新たに取り入れられました。
配列に含まれる要素を変数として取り出し、その数だけ繰り返し処理を行うということをレッスン７では学びました。

`for ... of`では、配列、文字列、マップ、DOMの繰り返し処理に使われていて、ES6から導入された新しい構文です。

構文はレッスン7で習った通り、`for ... in`と非常によく似ていますが、オブジェクトには利用出来ないことに注意しましょう。
`for ... of`を使うことによって、配列の値が1つずつ変数へ代入されていくので、それぞれの配列の値に対して処理を実行できます。
具体的なfor文との違いは、上記にも描いていますが、繰り返す回数やカウンタ変数を指定しなくても良いところです。

ただし、比較的新しい構文のため、古いブラウザでは対応していないこともあります。
**_for ... of文_**と配列を組み合わせて使うメリットは、やはり構文がfor文と比べて簡潔に済むところでしょう。

上記の配列とfor文の項目にある配列の反復例をもう一度比較してみましょう。

```js
// for
let arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) { // ループを繰り返す回数やカウンタ変数の指定が必要
  console.log(arr[i]);
}
// 1 2 3

// for ... of
for (v of arr) {// ループを繰り返す回数やカウンタ変数指定は不要
  console.log(v);
}// 1 2 3
```

書くコードも少なく、構造もシンプルです。
どちらも使えた方が良いですが、開発環境によって（古いブラウザの考慮をする必要があるかないかなど）使い分けができると良いですね。

**_for ... of文_**はそのほかでいうとDOMの取得でも組み合わせることができ、非常に便利です。

# 配列の分割代入

分割代入を配列でするには以下の例のように、それぞれの変数に一つずつ配列要素を代入していきます。

```javascript
const arr = [1, 2, 3];
const [a, b, c] = arr;
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

カンマと空欄を用いることで、必要のない要素を`undefined`にし、必要な配列要素だけを呼び出すことができます。

```javascript
const arr = [1, 2, 3];
const [ , , a] = arr;

console.log(a); // 3, undefined
```


# オブジェクト（Object）

## オブジェクトとは

オブジェクトについてはレッスン2ですでに詳しく概要を学んでいます。
オブジェクトはいわゆる**入れ物=箱**のようなものであり、入れ物としての箱は変わらず、箱の中身だけが時間や処理の進行に伴って変わっているイメージということを学びました。

ここでは簡単に配列を詳しく学んだので、配列との違いを比較してみます。

```
<配列>
- 配列には値がある。インデックス番号でアクセスが可能。
- 配列要素には順番がある。

<オブジェクト>
- オブジェクトにはプロパティ（オブジェクトに記載される内容）がある。文字列、もしくはシンボルを使って要素にアクセスが可能。
- オブジェクトのプロパティには順序がない。
```

ちなみに、**連想配列**というものを専門書や様々なところで見かけることがあるかと思いますが、他のプログラムで言う連想配列とは、JavaScriptではオブジェクトと同じとみなされます。

ただし、JavaScriptのオブジェクトには値としてデータだけでなく、関数処理も入れることができるのが特徴です。
つまり連想配列でも関数が値として入っている場合はオブジェクトと呼びます。

## オブジェクトの値の取り出し

オブジェクトの値を取り出すには、`Object.values()`を使うことで取得できます。
ここで`Object.values()`を使って、映画スターウォーズ/フォースの覚醒の主人公であるジェダイ、レイの名前と出身惑星を取り出してみましょう。

```javascript
const obj = {
  name: 'Rey',
  from: 'Jakku',
};

console.log(Object.values(obj)); // ['Rey', 'Jakku']
```

戻り値として、オブジェクトが所有しているプロパティの値からなる配列、つまりレイの名前と、レイの出身惑星、ジャクーが値として返ってきました。

## オブジェクトの初期化

オブジェクトの初期化には2つ方法があり。**オブジェクト初期化子**と**コンストラクタ関数**を使用する方法です。

名前だけ見ると理解が難しいので、実際に例を先に見てみましょう。
ジェダイであるレイのプロフィールを、オブジェクトの初期化子とコンストラクタ関数を使って紹介してみます。

```javascript

// オブジェクト初期化子
const obj = {}; // 空のオブジェクトを作成

// personオブジェクト作成
const person =  {
  name: "Rey",
  gender: "female",
  info: {
    occupation: "Jedi", // ２階層でオブジェクトを入れることも可
    affiliation: "Resistance",
  },
};
console.log(person.name, person.gender, person.info.occupation, person.info.affiliation);// Rey female Jedi Resistance
```

まず空のオブジェクトを作成した後に、`person`という新たなオブジェクトを作り、初期化を図っています。
レッスン2でも出てきたプロパティにアクセスするためのドット「.」**メンバーアクセス演算子**を使って、レイのプロフィール情報にアクセスしています。

```js
// コンストラクタ関数

// 関数を定義
function Person (name, gender, info) {
  this.name = name;
  this.gender = gender;
  this.info = info;
}

// newでインスタンス化
const person = new Person(
  "Rey",
  "female",
  {
    occupation: "Jedi",
    affiliation: "Resistance"
  }
);

console.log(person.name); //　Rey
```

このようにコンストラクタ関数を使って新たにオブジェクトを作成することを**インスタンス化**と呼びます。また生成されたオブジェクトのことを**インスタンス**と呼びます。`person`はPersonというコンストラクタ関数のインスタンスと言えます。

## オブジェクトのスプレッド演算子 ...

上記の配列でもスプレッド演算子について学びました。
ここではオブジェクトでスプレッド演算子を表記する例を見ていきましょう。

```javascript
const arr = { a: 1, b: 2 };

// オブジェクトのクローン
const arrClone = {...arr};
console.log(arrClone); // { a: 1, b: 2 }

// プロパティを追加した新しいオブジェクトの生成
const addNewArr = {...arr, c: 3};
console.log(addNewArr);// { a: 1, b: 2, c: 3 }

// オブジェクトのマージ
const arrMerge = {...arr, ...{c: 3, d: 4}};
console.log(arrMerge);// { a: 1, b: 2, c: 3, d: 4 }

// 元のオブジェクトに同名プロパティがある場合は置き換わる
const foo = {...arr, b: 3};
console.log(foo);// { a: 1, b: 3 }
const yaa = {...arr, ...{a: 3, b: 4}};
console.log(yaa);// { a: 3, b: 4 }
```

`Object.assign()`という書き方をするメソッドのものもありますが、スプレッド演算子で書き換えが可能になります。

## オブジェクトの分割代入

上記のスプレッド演算子を使用することで、配列でもオブジェクトでも**分割代入（Destructing Assignment）**が、簡潔に記述できるようになります。
上記の配列の文化いつ代入でも使った例にオブジェクトの例を加えて、以下の配列とオブジェクトの構文（スプレッド演算子なし）をまずは見ていきましょう。

```js
const arr = [1, 2, 3];
const [a, b, c] = arr;

console.log(a); // 1
console.log(b); // 2
console.log(c); // 3

const obj = {
  foo: 1,
  yaa: 2,
  boo: 3
};
const { foo } = obj;

console.log(foo); // 1
console.log(yaa); // 2
console.log(boo); // 3
```

上記の構文ではスプレッド演算子を用いていません。
そのため、要素を取り出してから、個別にそれぞれの変数`a, b, c`に代入しています。

この構文の方法でも十分便利ではありますが、個別に変数に代入するのは少し重複して書く似た内容が多いですね。
スプレッド演算子を組み合わせることで、配列要素を取り出しながら、その残りを変数に一気に代入することができます。

```js
const arr = [1, 2, 3];
const [d, ...e] = arr;

console.log(d); // 1
console.log(e); // [2, 3]

const obj = {
  foo: 1,
  yaa: 2,
  boo: 3
};
const { foo, ...rest } = obj;

console.log(foo); // 1
console.log(rest); // { yaa: 2, boo: 3 }
```

`...rest`でスプレッド演算子を使用して、一括で残りの配列要素である「2, 3」を変数eやrestに一気に代入しています。

## オブジェクトの更新/書き換え

オブジェクトを初期化するオブジェクト初期化子で、スターウォーズの主人公の一人であるジェダイ、レイのプロフィール情報を初期化によって参照しました。

今度は別のジェダイ、ルークのプロフィールをレイのプロフィールから更新しようと思います。

```js
const obj = {};

const person =  {
  name: "Rey",
  gender: "female",
  info: {
    occupation: "Jedi",
    affiliation: "Resistance",
  }
}

person.name = "Luke";
person.gender = "male";
console.log(person.name, person.gender); // Luke male
```

これで新しく、同じジェダイでもレイではなく、ルークのプロフィールに更新/書き換えされました。

## オブジェクトの削除

今度はオブジェクトを削除してみましょう。
正確にはオブジェクトのプロパティを消すメソッドで、配列でも出てきたdelete演算子を使ってオブジェクトも削除することができます。

上記でレイのプロフィールをルークのプロフィールに書き換えましたが、性別にあたる`gender`を削除してみます。

```js
delete person.gender;
console.log(person); // {name: "Luke", info: {occupation: "Jedi", affiliation: "Resistance"}
```

性別にあたる`gender`の値だけ削除することに成功しました。

## オブジェクトとfor-in文、forEachとObject.keys

オブジェクトと組み合わせて使えるループには以下の種類があります。

```js
// for ... in
let obj = {num1: 1, num2: 2, num3: 3};

for (let v in obj) {
  console.log(obj[v]);
} // 1 2 3

// forEach と Object.keysの組み合わせ
Object.keys(obj).forEach((key) => {
  console.log(key + ':' + obj[key]);
}); // num1:1 num2:2 num3:3
```

for文は上記の配列でも確認しましたが、そのほか、`for ... in`、`forEach`と`Object.keys`の組み合わせについて簡単に復習すると、以下の内容になります。

- `for ... in` - オブジェクトの中身を取得し、その個数分だけ繰り返し処理が可能。ただし、配列の`for ... in`のようにリスクがある。

- `forEach`と`Object.keys`の組み合わせ - Object.keysで配列にしてからforEachしている。forEachは配列に特化した構文。配列データの値1つずつにコールバック関数に記述した処理を実行する。

forEach構文も、`for ... of`と同様に「繰り返し回数」や「カウンタ変数」などを用意する必要なく扱えるため、最近ではよく使われています。

## チャレンジ

- [チャレンジ10](./challenge/README.md)

## 更に学ぼう

### 動画で学ぶ

- [JavaScript入門 - ドットインストール](https://dotinstall.com/lessons/basic_javascript_v2)

### 本で学ぶ

- [Eloquent JavaScript 3rd Edition](http://eloquentjavascript.net/)
